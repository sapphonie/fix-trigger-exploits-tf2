#include <sourcemod>
#include <sdkhooks>
#include <sdktools>


#pragma semicolon 1
#pragma newdecls required

public Plugin myinfo = {
    name           = "[TF2] Fix exploiting payload triggers",
    author         = "steph&nie",
    description    = "Prevent dropped weapons and other physics objects from triggering the end of the round in poorly made payload maps",
    version        = "0.0.1",
    url            = "https://sappho.io"
};

// define solidflags
enum SolidFlags_t
{
    FSOLID_CUSTOMRAYTEST                = 0x0001,    // Ignore solid type + always call into the entity for ray tests
    FSOLID_CUSTOMBOXTEST                = 0x0002,    // Ignore solid type + always call into the entity for swept box tests
    FSOLID_NOT_SOLID                    = 0x0004,    // Are we currently not solid?
    FSOLID_TRIGGER                      = 0x0008,    // This is something may be collideable but fires touch functions
                                                     // ... even when it's not collideable (when the FSOLID_NOT_SOLID flag is set)
    FSOLID_NOT_STANDABLE                = 0x0010,    // You can't stand on this
    FSOLID_VOLUME_CONTENTS              = 0x0020,    // Contains volumetric contents (like water)
    FSOLID_FORCE_WORLD_ALIGNED          = 0x0040,    // Forces the collision rep to be world-aligned even if it's SOLID_BSP or SOLID_VPHYSICS
    FSOLID_USE_TRIGGER_BOUNDS           = 0x0080,    // Uses a special trigger bounds separate from the normal OBB
    FSOLID_ROOT_PARENT_ALIGNED          = 0x0100,    // Collisions are defined in root parent's local coordinate space
    FSOLID_TRIGGER_TOUCH_DEBRIS         = 0x0200,    // This trigger will touch debris objects

    FSOLID_MAX_BITS    = 10
};

public void OnPluginStart()
{
    // check if tf2, unload if not
    if (GetEngineVersion() != Engine_TF2)
    {
        SetFailState("This plugin is only supported for TF2! Aborting!");
    }

    HookEvent("teamplay_round_start", RoundStart);
    HookEvent("teamplay_restart_round", RoundStart);

    OnMapStart();
}

public Action RoundStart(Handle event, const char[] name, bool dontBroadcast)
{
    OnMapStart();
}

public void OnMapStart()
{
    // init variable
    //int ent = -1;
    // does this entity exist?
    //while ((ent = FindEntityByClassname(ent, "trigger*")) > 0)
    //{
    //    if (IsValidEntity(ent) && ent > 0)
    //    {
    //        CheckIfCapTrigger(ent);
    //    }
    //}
    // ^ this is faster,
    // v but this is more consistent with the rest of this code
    for (int ent = 1; ent < GetMaxEntities(); ent++)
    {
        if (IsValidEntity(ent))
        {
            char className[128];
            // get name of this entity
            GetEntityClassname(ent, className, sizeof(className));
            if (StrContains(className, "trigger") != -1)
            {
                CheckIfCapTrigger(ent);
            }
        }
    }
}



// just in case
public void OnEntityCreated(int entity, const char[] className)
{
    if (StrContains(className, "trigger") != -1)
    {
        CheckIfCapTrigger(entity);
    }
}

void CheckIfCapTrigger(int entity)
{
    char entname[128];
    // get "real name" of entity, i.e. what it's named when you look at it in hammer editor
    GetEntPropString(entity, Prop_Data, "m_iName", entname, sizeof(entname));
    // does it have any of these strings in it?
    if
    (
           StrContains(entname, "capture_trigger")  != -1
        || StrContains(entname, "capturetrigger")   != -1
        || StrContains(entname, "captrigger")       != -1
    )
    {
        LogMessage("fixed trigger");
        // grab flags
        int triggerFlags = GetEntProp(entity, Prop_Data, "m_usSolidFlags");
        // delete the flag that lets physics props / dropped weapons trigger the trigger
        triggerFlags &= ~view_as<int>(FSOLID_TRIGGER_TOUCH_DEBRIS);
        // actually set the ent prop
        SetEntProp(entity, Prop_Data, "m_usSolidFlags", triggerFlags);
    }
}